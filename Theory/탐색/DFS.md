### 그래프의 기본 구조

- 그래프는 **노드** 와 **간선** 으로 표현되며, 이때 노드를 정점이라고도 말함.
  <br>

![image](https://user-images.githubusercontent.com/77706631/161599793-a79b856a-c70a-422e-81c9-3389eac18a0a.png)

<br>

### 그래프 탐색이란?

- 하나의 노드를 시작으로 다수의 노드를 방문하는 것
- 두 노드가 간선으로 연결되어 있다면 '두 노드는 인접하다' 라고 표현

<Br>

### 그래프 표현 방식

- **인접 행렬 (Adjacency Matrix)**
  - `2차원 배열에 각 노드가 연결된 형태를 기록하는 방식`
  - 파이썬에서는 2차원 리스트로 구현
  - 연결되어 있지 않은 노드끼리는 무한의 비용이라고 작성
    - 실제 코드에서 논리적으로 정답이 될 수 없는 큰 값 중에서 999999999, 987654321 등으로 초기화하는 경우가 많음.

<br>

```python
INF = 999999999 # 무한 비용 선언

# 2차원 리스트를 이용하여 인접 행렬 표현
graph = [
  [0, 7, 5],
  [7, 0, INF],
  [5, INF, 0]
]
```

<br>

- **인접 리스트 (Adjacency List)**
  - `리스트 자료형을 이용하여 그래프의 연결 관계를 표현하는 방식`

<br>

```python
# 행(Row) 이 3개인 2차원 리스트로 인접 리스트 표현
graph = [[] for _ in range(3)]

# 노드 0 에 연결된 노드 정보 저장 (노드, 거리)
graph[0].append((1, 7))
graph[0].append((2, 5))

# 노드 1 에 연결된 노드 정보 저장 (노드, 거리)
graph[1].append((0, 7))

# 노드 2 에 연결된 노드 정보 저장 (노드, 거리)
graph[2].append((0, 5))
```

<Br>

### 인접 행렬 vs 인접 리스트

- `메모리 측면`
  - 인접 행렬 방식은 모든 관계를 저장하므로 노드 개수가 많을수록 메모리 낭비 ↑
  - 인접 리스트 방식은 연결된 정보만을 저장하기 때문에 메모리를 효율적으로 사용
    <br>
- `속도 측면`
  - 인접 리스트 방식은 연결된 데이터를 하나씩 확인해야 하기 때문에 정보를 얻는 속도 ↓
    <br>

### 깊이 우선 탐색 : DFS (Depth-First Search)

> 💡 **그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘**

<br>

- 특정한 경로로 탐색하다가 특정 상황에서 최대한 깊숙이 들어가서 노드 방문 후, 다시 돌아가 다른 경로로 탐색

<br>

#### **DFS 동작 과정 (스택 이용)**

1. 탐색 시작 노드를 스택에 삽입하고 방문 처리
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있다면 그 인접 노드를 스택에 넣고 방문 처리.
   2-1) 방문하지 않은 인접 노드가 없다면 스택에서 최상단 노드를 꺼냄.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복

<br>

##### ※ 방문 처리

스택에 한 번 삽입되어 처리된 노드가 다시 삽입되지 않게 체크하는 것을 의미
-> 각 노드를 한 번씩만 처리하는 것이 가능해짐.

<br>

### <예제 5-8>

```python
# DFS 메서드 정의
def dfs(graph, v, visited) :
  # 현재 노드를 방문 처리
  visited[v] = True
  print(v, end=' ')
  # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
  for i in graph[v] :
    if not visited[i] :
      dfs(graph, i, visited)

# 각 노드가 연결된 정보를 리스트 자료형으로 표현 (2차원 리스트)
graph = [
  [],
  [2, 3, 8],
  [1, 7],
  [1, 4, 5],
  [3, 5],
  [3, 4],
  [7],
  [2, 6, 8],
  [1, 7]
]

# 각 노드가 방문된 정보를 리스트 자료형으로 표현 (1차원 리스트)
visited = [False] * 9

# 정의된 DFS 함수 호출
dfs(graph, 1, visited)

# 출력 결과
# => 1 2 7 6 8 3 4 5
```

<br>

#### 시간 복잡도 분석

- 깊이 우선 탐색 알고리즘 DFS 는 스택 자료구조에 기초한다는 점에서 구현이 간단
  - 재귀 함수를 이용하면 매우 간결하게 구현 가능
    <br>
- 탐색 수행 시 데이터 개수가 N 개인 경우 O(N) 의 시간이 소요

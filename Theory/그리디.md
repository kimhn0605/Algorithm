### 구현

> 💡 **현재 상황에서 지금 당장 좋은것만 고르는 방법**

<br>

- 매 순간 가장 좋아보이는 것을 선택하며, 현재의 선택이 나중에 미칠 영향에 대해서는 고려 X

- 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 답을 도출할 수 있음.

<br>

### <예제 3-1> 거스름돈

#### 문제 설명

- 당신은 음식점의 계산을 도와주는 점원이다. 카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정한다. 손님에게 거슬러 줘야 할 돈이 N원일 때 거슬러 줘야 할 동전의 최소 개수를 구해라. 단, 거슬러 줘야 할 돈 N은 항상 10의 배수이다.
  <br>

#### 문제 해결 아이디어

> 💡**가장 큰 화폐부터 돈을 거슬러 주는 것**

<br>

1. 거슬러 준 돈 : 0원
   남은 돈 : 1,260원
   | 화폐 단위 | 500 | 100 | 50 | 10 |
   | ---------------- | --- | --- | --- | --- |
   | 손님이 받은 개수 | 0 | 0 | 0 | 0 |

  <br>

2. 거슬러 준 돈 : 500 \* 2 = 1000원
   남은 돈 : 260원
   | 화폐 단위 | 500 | 100 | 50 | 10 |
   | --------- | --- | --- | --- | --- |
   | 손님이 받은 개수 | 2 | 0 | 0 | 0 |

<br>

3. 거슬러 준 돈 : 100 \* 2 = 200원
   남은 돈 : 60원
   | 화폐 단위 | 500 | 100 | 50 | 10 |
   | --------- | --- | --- | --- | --- |
   | 손님이 받은 개수 | 2 | 2 | 0 | 0 |
   <br>

4. 거슬러 준 돈 : 50 \* 1 = 50원
   남은 돈 : 10원
   | 화폐 단위 | 500 | 100 | 50 | 10 |
   | --------- | --- | --- | --- | --- |
   | 손님이 받은 개수 | 2 | 2 | 1 | 0 |
   <br>

5. 거슬러 준 돈 : 10 \* 1 = 10원
   남은 돈 : 0원
   | 화폐 단위 | 500 | 100 | 50 | 10 |
   | --------- | --- | --- | --- | --- |
   | 손님이 받은 개수 | 2 | 2 | 1 | 1 |
   <br>

#### 답안 예시

```python
n = 1260
count = 0

# 큰 단위의 화폐부터 차례대로 확인
coin_types =[500, 100, 50, 10]

for coin in coin_types :  # 해당 화폐로 거슬러 줄 수 있는 동전 개수
  count += (n // coin)
  n %= coin

print(count)
```

<br>

#### 시간 복잡도 분석

- 화폐의 종류가 K개라고 할 때 위 코드의 시간 복잡도는 **O(K)**
- `이 알고리즘의 사간 복잡도는 동전의 종류에만 영향을 받고, 거슬러 줘야 하는 금액의 크기와는 무관`
  <br>

#### 그리디 알고리즘의 정당성

- 가지고 있는 동전 중에서 **큰 단위가 항상 작은 단위의 배수**이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문에 그리디 알고리즘으로 해결 가능
